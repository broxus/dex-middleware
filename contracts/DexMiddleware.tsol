pragma ever-solidity >=0.62.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "./lib/Payload.tsol";
import "./lib/Constants.tsol";

import "./interfaces/IDexMiddleware.tsol";
import "./interfaces/IDexChildMiddleware.tsol";

import "./DexChildMiddleware.tsol";
import "./base/DexMiddlewareBase.tsol";

import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IAcceptTokensMintCallback.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/IBurnableTokenWallet.tsol";


import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "broxus-ton-tokens-contracts/contracts/interfaces/ITokenWallet.tsol";
import "broxus-ton-tokens-contracts/contracts/abstract/TokenWalletDestroyableBase.tsol";
import "./lib/DexLibraries.tsol";

import "locklift/src/console.tsol";


contract DexMiddleware is IAcceptTokensTransferCallback, IAcceptTokensMintCallback, DexMiddlewareBase {

    constructor() public {
        require (tvm.pubkey() != 0, ErrorCodes.NOT_OWNER);
        require (tvm.pubkey() == msg.pubkey(), ErrorCodes.NOT_OWNER);
        tvm.accept();
    }


    function onAcceptTokensTransfer(
        address,
        uint128 _amount,
        address,
        address,
        address _remainingGasTo,
        TvmCell _payload
    ) override external {

        handleTokensTransfer(
            _amount,
            _remainingGasTo,
            _payload
        );
    }

    function onAcceptTokensMint(
        address,
        uint128 _amount,
        address _remainingGasTo,
        TvmCell _payload
    ) override external {
        handleTokensTransfer(
            _amount,
            _remainingGasTo,
            _payload
        );
    }
    function calculateFeeAndTokensValue(TvmCell _transferPayload) override public pure returns (CommonStructures.CalculationResult) {
        (
            CommonStructures.PayloadForDex[] payloadsForDex,
            CommonStructures.PayloadForTransfer[] payloadsForTransfer,
            CommonStructures.PayloadForBurn[] payloadsForBurn,
        ) = Payload.encodePayload(_transferPayload);

        CommonStructures.CalculationResult calculationResult = _calculateFeeAndTokensValue(payloadsForDex, payloadsForTransfer, payloadsForBurn);
        calculationResult.everValue +=
            uint128(payloadsForDex.length) * Constants.ADDITIONAL_EVER_VALUE +
            uint128(payloadsForTransfer.length) * Constants.ADDITIONAL_EVER_VALUE +
            uint128(payloadsForBurn.length) * Constants.ADDITIONAL_EVER_VALUE;
        return calculationResult;
    }
    function _calculateFeeAndTokensValue(
        CommonStructures.PayloadForDex[] _payloadsForDex,
        CommonStructures.PayloadForTransfer[] _payloadsForTransfer,
        CommonStructures.PayloadForBurn[] _payloadsForBurn
    ) internal pure returns (CommonStructures.CalculationResult) {
        uint128 requiredValue;
        uint128 requiredTokenAmount;
        for (CommonStructures.PayloadForTransfer _transferConfig : _payloadsForTransfer) {
            requiredTokenAmount += _transferConfig.amount;
            requiredValue += (_transferConfig.attachedValue + _transferConfig.deployWalletValue);
        }

        for (CommonStructures.PayloadForBurn payloadForBurn : _payloadsForBurn) {
            requiredValue += payloadForBurn.attachedValue;
            requiredTokenAmount += payloadForBurn.amount;
        }

        for (CommonStructures.PayloadForDex _dexConfig : _payloadsForDex) {
            requiredTokenAmount += _dexConfig.tokensAmount;

            requiredValue += getTotalValueForDexOperation(_dexConfig);
        }

        return CommonStructures.CalculationResult({
            everValue: requiredValue,
            tokenAmount: requiredTokenAmount
        });
    }

    function getTotalValueForDexOperation(CommonStructures.PayloadForDex _dexConfig) internal pure returns (uint128) {

        uint128 maxValueForFinalTransfer = math.max(_dexConfig.successPayload.valueForFinalTransfer, _dexConfig.cancelPayload.valueForFinalTransfer);

        uint128 maxDeployWalletValue = math.max(
            math.max(_dexConfig.successPayload.deployWalletValue, _dexConfig.cancelPayload.deployWalletValue),
            Constants.DEPLOY_WALLET_VALUE
        );

        return Constants.DEPLOY_CHILD_VALUE +
            _dexConfig.valueForDexOperation +
            _dexConfig.leaves *
            (
                maxValueForFinalTransfer +
                maxDeployWalletValue
            );
    }

    function checkIsEnoughValueAndTokens(
        CommonStructures.PayloadForDex[] _payloadsForDex,
        CommonStructures.PayloadForTransfer[] _payloadsForTransfer,
        CommonStructures.PayloadForBurn[] _payloadsForBurn,
        uint128 _receivedTokensAmount
    ) internal pure returns(bool, uint128) {
        CommonStructures.CalculationResult calculationResult = _calculateFeeAndTokensValue(_payloadsForDex, _payloadsForTransfer, _payloadsForBurn);

        if (msg.value < calculationResult.everValue) {
            return (false, 0);
        }
        if (_receivedTokensAmount < calculationResult.tokenAmount) {
            return (false, 0);
        }
        return (true, _receivedTokensAmount - calculationResult.tokenAmount);
    }

    function handleTokensTransfer(
        uint128 _amount,
        address _remainingGasTo,
        TvmCell _payload
    ) internal {
        tvm.rawReserve(_reserve(), 0);

        (
            CommonStructures.PayloadForDex[] payloadsForDex,
            CommonStructures.PayloadForTransfer[] payloadsForTransfer,
            CommonStructures.PayloadForBurn[] payloadsForBurn,
            address remainingTokensTo
        ) = Payload.encodePayload(_payload);

        (
            bool isEnoughTokensAndValue,
            uint128 extraTokensAmount
        ) = checkIsEnoughValueAndTokens(payloadsForDex, payloadsForTransfer, payloadsForBurn, _amount);

        if (!isEnoughTokensAndValue || isPaused) {
            ITokenWallet(msg.sender).transfer{value: 0, flag:MsgFlag.ALL_NOT_RESERVED, bounce: false}(
                _amount,
                remainingTokensTo,
                0,
                _remainingGasTo,
                true,
                _payload
            );
            return;
        }

        if (extraTokensAmount > 0) {
            ITokenWallet(msg.sender).transfer{value: Constants.EXTRA_TOKENS_TRANSFER_VALUE, bounce: false}(
                extraTokensAmount,
                remainingTokensTo,
                0,
                _remainingGasTo,
                true,
                _payload
            );
        }

        makeTransfers(payloadsForTransfer);
        makeBurns(payloadsForBurn);
        createChildProcesses(payloadsForDex);
        _remainingGasTo.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function makeTransfers(CommonStructures.PayloadForTransfer[] _payloadsForTransfer) internal pure {
        for (CommonStructures.PayloadForTransfer transferConfig : _payloadsForTransfer) {

            ITokenWallet(msg.sender).transfer{value: transferConfig.attachedValue + transferConfig.deployWalletValue, bounce: false}(
                transferConfig.amount,
                transferConfig.receiver,
                transferConfig.deployWalletValue,
                transferConfig._remainingGasTo,
                transferConfig.notify,
                transferConfig.payload
            );
        }
    }

    function makeBurns(CommonStructures.PayloadForBurn[] _payloadsForBurn) internal pure {
        for (CommonStructures.PayloadForBurn burnConfig : _payloadsForBurn) {
            IBurnableTokenWallet(msg.sender).burn{value: burnConfig.attachedValue, bounce: false}(
                burnConfig.amount,
                burnConfig.remainingGasTo,
                burnConfig.callbackTo,
                burnConfig.payload
            );
        }
    }

    function createChildProcesses(CommonStructures.PayloadForDex[] _payloadsForDex) internal {
        for (CommonStructures.PayloadForDex dexConfig : _payloadsForDex) {

            uint128 totalValueForDexOperation = getTotalValueForDexOperation(dexConfig);

            address child = deployChild(
                currentChildNonce++,
                msg.sender,
                dexConfig.dexPayload,
                dexConfig.tokensAmount,
                dexConfig.valueForDexOperation,
                totalValueForDexOperation,
                dexConfig.rootToSendersAllowanceMap,
                dexConfig.leaves,
                dexConfig.firstRoot,
                dexConfig.remainingGasTo,
                dexConfig.successPayload,
                dexConfig.cancelPayload
            );
            emit DeployChild(child);
        }
    }

    function onChildRequestTokens(uint128 _childNonce,address _rootWallet, uint128 _tokensAmount) override external onlyChild(_childNonce) {
        tvm.rawReserve(_reserve(), 0);
        TvmCell dummyPayload;
        uint128 deployChildWalletValue = msg.value / 2;
        ITokenWallet(_rootWallet).transfer{value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false}(
            _tokensAmount,
            msg.sender,
            deployChildWalletValue,
            msg.sender,
            true,
            dummyPayload
        );
    }


    function forceChildsFinalize(CommonStructures.ForceChildFinalize[] childsSettings) onlyOwner override external {
        tvm.rawReserve(_reserve(), 0);
        uint32 countOfChilds = uint32(childsSettings.length);

        require(msg.value >= countOfChilds * Constants.FORCE_CHILD_FINALIZE_VALUE);

        for (CommonStructures.ForceChildFinalize childsSetting : childsSettings) {
            IDexChildMiddleware(childsSetting.child).forceFinalize{value: Constants.FORCE_CHILD_FINALIZE_VALUE, bounce: false}(childsSetting.isSuccess);
        }
        msg.sender.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    function upgrade(TvmCell _newCode, uint32 _newVersion, address _sendGaTo) onlyOwner override external {
        if (dexMiddlewareVersion == _newVersion) {
            tvm.rawReserve(_reserve(), 0);
            _sendGaTo.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
            return;
        }

        TvmCell data = abi.encode(
            nonce, // uint128
            owner, // address
            _newVersion, // uint32
            dexMiddlewareChildCode, // TvmCell
            isPaused, // bool
            currentChildNonce, // uint128
            childVersion // uint32
        );

        tvm.setcode(_newCode);
        tvm.setCurrentCode(_newCode);

        onCodeUpgrade(data);

    }

    function onCodeUpgrade(TvmCell _upgradeData) private {}

}
